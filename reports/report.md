# 栈溢出攻击实验

## 题目解决思路


### Problem 1: 
- **分析**：本题的核心在于利用 memcpy 函数造成的缓冲区溢出漏洞来覆盖函数的返回地址。通过反汇编 problem3，确定缓冲区大小为 32 字节，加上栈帧中保存的 RBP 寄存器占用的 8 字节，总计偏移 40 字节即可到达返回地址。此时，将返回地址修改为目标函数 func1 的起始地址，即可在 func 返回时劫持控制流，直接执行 func1。
- **解决方案**：利用 Python 的 struct 模块构造 40 字节的填充字符加上小端序的目标函数地址。最后生成了一个二进制文件，其末尾 8 字节正好是目标跳转地址。
- **结果**：
![Problem 1 运行截图](./p1_result.png)

### Problem 2:
- **分析**：本题在溢出的基础上增加了寄存器传参的要求，即跳转到 func1 的同时，必须保证第一个参数寄存器 %rdi 的值为 0x72。由于直接溢出只能控制栈数据，不能直接修改寄存器，因此需要寻找 ROP Gadget。通过该指令片段，程序可以从栈中弹出一个预设的值到 %rdi，随后再通过 ret 跳转到目标函数，从而完成带参调用。
- **解决方案**：构造一个 ROP 链，填充 40 字节后，依次写入 pop rdi; ret 指令的地址、参数值 0x72、以及 func1 的起始地址。 
- **结果**：
![Problem 2 运行截图](./p2_result.png)


## 思考与总结
在 x86-64 架构下，虽然有栈保护和地址随机化等防御机制，但只要程序逻辑存在对输入长度的信任问题，攻击者就能通过覆盖返回地址或构造 ROP 链的方式夺取控制权。实验不仅锻炼了使用 objdump 和 gdb 进行二进制分析的能力，同时展示了在开发过程中使用 strncpy 或 memcpy_s 等安全函数的重要性。


